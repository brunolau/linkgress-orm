## `exists()` in SELECT projections, `collection.exists()`, and `selectMany()`

### `exists()` / `notExists()` in SELECT projections

`exists()` and `notExists()` now work in SELECT projections (not just WHERE clauses), returning a typed `boolean`:

```typescript
const result = await db.users
  .select(u => ({
    username: u.username,
    hasPosts: exists(
      db.posts
        .where(p => eq(p.userId, u.id))
        .select(p => ({ id: p.id }))
        .asSubquery('table')
    ),
  }))
  .toList();
// result[0].hasPosts is boolean
```

`ExistsCondition` and `NotExistsCondition` now extend `SqlFragment<boolean>` instead of `WhereConditionBase`. Since `SqlFragment` extends `WhereConditionBase`, existing WHERE usage is preserved. `UnwrapSelection<SqlFragment<boolean>>` resolves to `boolean` for correct type inference.

### `collection.exists()`

Navigation collections now support `.exists()` alongside the existing `.count()`, `.min()`, `.max()`, `.sum()`:

```typescript
const result = await db.users
  .select(u => ({
    username: u.username,
    hasPosts: u.posts!.exists(),
    hasPopularPosts: u.posts!.where(p => sql<boolean>`${p.views} > 150`).exists(),
  }))
  .toList();
// hasPosts: true/false per user
```

Works with all three collection strategies (CTE, lateral, temp table).

### `selectMany()` for flattening nested collections

`selectMany()` flattens a nested collection through an intermediate table, similar to LINQ/EF Core:

```typescript
const result = await db.products
  .select(p => ({
    name: p.name,
    // Flatten: product → productPrices → productPriceCapacityGroups
    hasCapacityGroups: p.productPrices!
      .selectMany(pp => pp.productPriceCapacityGroups!)
      .exists(),
    capacityGroupCount: p.productPrices!
      .selectMany(pp => pp.productPriceCapacityGroups!)
      .count(),
  }))
  .toList();
```

`selectMany()` chains with all collection operations:
- `.exists()` / `.count()` — scalar aggregations on flattened collection
- `.where().exists()` / `.where().count()` — filtered aggregations
- `.select(x => ({ ... })).toList()` — projected list of flattened items
- `.toList()` — full entity list
- `.selectDistinct(x => x.field).toNumberList()` — distinct scalar lists
- Navigation properties on inner items (e.g., `.select(x => ({ name: x.capacityGroup!.name }))`)

### Files changed

- `src/query/subquery.ts` — `ExistsCondition` and `NotExistsCondition` extend `SqlFragment<boolean>` instead of `WhereConditionBase`
- `src/query/query-builder.ts` — `CollectionQueryBuilder`: added `exists()`, `selectMany()` methods; `select()` carries over `selectManyJoins`/`foreignKeyTableAlias`; updated `buildCTE` aggregationType handling and default values for EXISTS
- `src/entity/db-context.ts` — `EntityCollectionQuery` interface: added `exists()` and `selectMany()` signatures
- `src/query/collection-strategy.interface.ts` — Added `'exists'` to `aggregationType` union; added `foreignKeyTableAlias` field
- `src/query/strategies/cte-collection-strategy.ts` — EXISTS aggregation; `foreignKeyTableAlias` support in all aggregation methods (jsonb, array, scalar, exists)
- `src/query/strategies/lateral-collection-strategy.ts` — EXISTS in correlated subquery and LATERAL paths; `foreignKeyTableAlias` correlation in all methods
- `src/query/strategies/temptable-collection-strategy.ts` — EXISTS aggregation via `bool_or`
