## Fix: Deep navigation in grouped queries

### Multi-level navigation in `.groupBy().select()` chains

Multi-level navigation properties (2+ levels) now work correctly in grouped query chains. Previously, patterns like `p.product.resort.timezone` or `ot.task.level.createdBy.email` inside a `.select().groupBy().select()` chain would crash with "cannot read property X of undefined" during query building.

```typescript
// Previously crashed — now works
const result = await db.productPrices
  .select(pp => ({
    productId: pp.productId,
    timezone: pp.product!.resort!.timezone, // 2-level navigation
    price: pp.price,
  }))
  .groupBy(p => ({
    productId: p.productId,
    timezone: p.timezone,
  }))
  .select(g => ({
    productId: g.key.productId,
    timezone: g.key.timezone,
    minPrice: g.min(p => p.price),
  }))
  .toList();
```

**Root cause:** `GroupedQueryBuilder` and `GroupedSelectQueryBuilder` did not propagate `schemaRegistry` to `ReferenceQueryBuilder` / `CollectionQueryBuilder` in their `createMockRow()` methods. Without the registry, nested navigation beyond 1 level couldn't resolve target schemas, falling back to a shallow proxy that returns `undefined` for deeper properties. Additionally, the JOIN detection in grouped queries used a single-level lookup (`this.schema.relations[alias]`) that couldn't resolve transitive joins through intermediate tables.

**Fix:**
- `schemaRegistry` is now threaded through `SelectQueryBuilder.groupBy()` → `GroupedQueryBuilder` → `GroupedSelectQueryBuilder` → both `createMockRow()` methods
- `detectAndAddJoinsFromSelection` replaced with a two-phase approach: first collect all table aliases (including `__navigationAliases` for intermediate tables), then iteratively resolve joins through the schema graph
- `detectAndAddJoinsFromCondition` updated with the same multi-level resolution
- JOIN conditions use `sourceAlias` for correct FK qualification on intermediate tables

### Files changed

- `src/query/query-builder.ts` — `SelectQueryBuilder.groupBy()` passes `this.schemaRegistry` to `GroupedQueryBuilder`
- `src/query/grouped-query.ts` — `GroupedQueryBuilder`: added `schemaRegistry` field/constructor param, passes it to `GroupedSelectQueryBuilder` and to `ReferenceQueryBuilder`/`CollectionQueryBuilder` in `createMockRow()`. `GroupedSelectQueryBuilder`: same `schemaRegistry` propagation. Replaced single-level `addJoinForFieldRef` with `collectTableAliasesFromSelection` + `resolveJoinsForTableAliases` (handles `__navigationAliases` for multi-level chains). Updated `detectAndAddJoinsFromCondition` to use multi-level resolution. JOIN builder uses `sourceAlias` for correct intermediate table FK references.

---

## Fix: Custom mapper not applied on navigation property fields

### `fromDriver` mapper skipped for fields accessed through navigation

Custom type mappers (`fromDriver`) were not applied when selecting a field through a navigation property. For example, `pc.post!.publishTime` would return the raw database value (a number) instead of the mapped application type (`{ hour, minute }`). This affected any navigation depth — 1-level, 2-level, and deeper.

```typescript
// Previously returned raw numbers — now correctly maps to { hour, minute } and Date
const results = await db.postComments
  .select(pc => ({
    id: pc.id,
    publishTime: pc.post!.publishTime,           // 1-level: HourMinute mapper
    customDate: pc.post!.customDate,              // 1-level: pgIntDatetime mapper
    authorLastActive: pc.post!.user!.lastActiveAt, // 2-level: pgIntDatetime mapper
  }))
  .toList();
```

**Root cause:** In `transformResults()`, the mapper lookup for FieldRefs only checked the base table's `schemaColumnCache`. When a FieldRef came from a navigation property (e.g., `publishTime` belongs to `Post`, not `PostComment`), the lookup missed because the base table's cache doesn't contain columns from navigated tables. The field fell through to `FieldType.SIMPLE`, bypassing the mapper entirely.

**Fix:** When the base table's schema cache has no entry for a FieldRef, check the `__mapper` property that `ReferenceQueryBuilder.createMockTargetRow()` already attaches to every FieldRef from the target table's column config. This works at any navigation depth since `__mapper` is set per-FieldRef regardless of how many levels deep the navigation chain goes.

### Files changed

- `src/query/query-builder.ts` — `transformResults()`: added fallback to `value.__mapper` in the FieldRef categorization when `schemaColumnCache` lookup returns no entry
